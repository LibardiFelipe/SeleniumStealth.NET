<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="FakeLoadingTimes" xml:space="preserve">
    <value>() =&gt; {
    console.log('Fake loading times injected!')
    try {
        if (!window.chrome) {
            Object.defineProperty(window, 'chrome', {
                writable: true,
                enumerable: true,
                configurable: false,
                value: {}
            })
        }

        if ('csi' in window.chrome) {
            return
        }

        if (!window.performance || !window.performance.timing) {
            return
        }

        const { timing } = window.performance

        window.chrome.csi = function () {
            return {
                onloadT: timing.domContentLoadedEventEnd,
                startE: timing.navigationStart,
                pageT: Date.now() - timing.navigationStart,
                tran: 15
            }
        }
        utils.patchToString(window.chrome.csi)
    } catch (e) {
        console.error('Fake loading times: ' + e)
    }
}</value>
  </data>
  <data name="FakeMouseMovement" xml:space="preserve">
    <value>() =&gt; {
  moveMouseCursorToElement = (element, ms) =&gt; {
    function getElementCoords(element) {
      const { top, left, width, height } = element.getBoundingClientRect();
      const x = left + width / 2;
      const y = top + height / 2;
      return { x, y };
    }

    function triggerMouseMove(coords) {
      const event = new MouseEvent("mousemove", {
        view: window,
        bubbles: true,
        cancelable: true,
        clientX: coords.x,
        clientY: coords.y,
      });
      document.body.dispatchEvent(event);
    }

    function simulateMouseMovement(element, ms) {
      // Pega a posição atual do cursor
      let startCoords = { x: 0, y: 0 };
      document.addEventListener("mousemove", function (event) {
        startCoords = { x: event.clientX, y: event.clientY };
      });

      const endCoords = getElementCoords(element);
      let steps = ms / 10;
      const xStep = (endCoords.x - startCoords.x) / steps;
      const yStep = (endCoords.y - startCoords.y) / steps;
      let currentCoords = { x: startCoords.x, y: startCoords.y };

      const moveMouse = setInterval(() =&gt; {
        if (steps-- &lt;= 0) {
          clearInterval(moveMouse);
          return;
        }
        currentCoords.x += xStep;
        currentCoords.y += yStep;
        triggerMouseMove(currentCoords);
      }, ms / steps);
    }

    document.body.addEventListener("mousemove", () =&gt; {
      console.log("Mouse move event triggered");
    });

    simulateMouseMovement(element, ms);
  }

  simulateRandomMouseMove = (ms) =&gt; {
      function randomCoords() {
        const x = Math.random() * window.innerWidth;
        const y = Math.random() * window.innerHeight;
        return { x, y };
      }
  
      function triggerMouseMove(coords) {
        const event = new MouseEvent("mousemove", {
          view: window,
          bubbles: true,
          cancelable: true,
          clientX: coords.x,
          clientY: coords.y,
        });
        document.body.dispatchEvent(event);
      }
  
      function simulateMouseMovement(interval) {
        const startCoords = randomCoords();
        const endCoords = randomCoords();
        const ms = interval;
        let steps = ms / 10;
        const xStep = (endCoords.x - startCoords.x) / steps;
        const yStep = (endCoords.y - startCoords.y) / steps;
        let currentCoords = { x: startCoords.x, y: startCoords.y };
  
        const moveMouse = setInterval(() =&gt; {
          if (steps-- &lt;= 0) {
            clearInterval(moveMouse);
            return;
          }
          currentCoords.x += xStep;
          currentCoords.y += yStep;
          triggerMouseMove(currentCoords);
        }, ms / steps);
      }
  
      document.body.addEventListener("mousemove", () =&gt; {
        console.log("Mouse move event triggered");
      });
  
      simulateMouseMovement(ms);
    }
}</value>
  </data>
  <data name="FixHairline" xml:space="preserve">
    <value>() =&gt; {
	console.log('Fix hairline injected!')
    try {
		const elementDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetHeight')

		Object.defineProperty(HTMLDivElement.prototype, 'offsetHeight', {
			...elementDescriptor,
			get: function () {
				if (this.id === 'modernizr') {
					return 1;
				}
				return elementDescriptor.get.apply(this)
			},
		});
    } catch (e) {
		console.error('Fix hairline: ' + e)
    }
}</value>
  </data>
  <data name="NavigatorVendor" xml:space="preserve">
    <value>(vendor) =&gt; {
  Object.defineProperty(Object.getPrototypeOf(navigator), 'vendor', {
    get: () =&gt; vendor || 'Google Inc.'
  })
}</value>
  </data>
  <data name="RemoveCdcVariables" xml:space="preserve">
    <value>() =&gt; {
    console.log('Remove CDC variables injected!')

    try {
        const regex = /..._[a-zA-Z0-9]{22}_(Array|Promise|Symbol)/;

        for (let prop in window) {
            if (regex.test(prop)) {
                delete window[prop];
            }
        }
    } catch (e) {
        console.error('Remove CDC variables:'+ e)
    }
}</value>
  </data>
  <data name="SeleniumStealth_FakeCanPlayType" xml:space="preserve">
    <value>() =&gt; {
    console.log('Fake CanPlayType injected!')
    try {
        const parseInput = arg =&gt; {
            const [mime, codecStr] = arg.trim().split(';')
            let codecs = []
            if (codecStr &amp;&amp; codecStr.includes('codecs=')) {
                codecs = codecStr
                    .trim()
                    .replace(`codecs='`, '')
                    .replace(`'`, '')
                    .trim()
                    .split(',')
                    .filter(x =&gt; !!x)
                    .map(x =&gt; x.trim())
            }
            return {
                mime,
                codecStr,
                codecs
            }
        }

        const canPlayType = {

            apply: function (target, ctx, args) {
                if (!args || !args.length) {
                    return target.apply(ctx, args)
                }
                const { mime, codecs } = parseInput(args[0])

                if (mime === 'video/mp4') {
                    if (codecs.includes('avc1.42E01E')) {
                        return 'probably'
                    }
                }

                if (mime === 'audio/x-m4a' &amp;&amp; !codecs.length) {
                    return 'maybe'
                }

                if (mime === 'audio/aac' &amp;&amp; !codecs.length) {
                    return 'probably'
                }

                return target.apply(ctx, args)
            }
        }

        utils.replaceWithProxy(
            HTMLMediaElement.prototype,
            'canPlayType',
            canPlayType
        )
    } catch (e) {
        console.error('Fake CanPlayType: ' + e)
    }
}</value>
  </data>
  <data name="SeleniumStealth_FakeChromeApp" xml:space="preserve">
    <value>() =&gt; {
    console.log('Fake chrome app injected!')
    try {
        if (!window.chrome) {

            Object.defineProperty(window, 'chrome', {
                writable: true,
                enumerable: true,
                configurable: false,
                value: {}
            })
        }

        if ('app' in window.chrome) {
            return
        }

        const makeError = {
            ErrorInInvocation: fn =&gt; {
                const err = new TypeError(`Error in invocation of app.${fn}()`)
                return utils.stripErrorWithAnchor(
                    err,
                    `at ${fn} (eval at &lt;anonymous&gt;`
                )
            }
        }

        const STATIC_DATA = JSON.parse(
            `
            {
            'isInstalled': false,
            'InstallState': {
                'DISABLED': 'disabled',
                'INSTALLED': 'installed',
                'NOT_INSTALLED': 'not_installed'
            },
                'RunningState': {
                    'CANNOT_RUN': 'cannot_run',
                    'READY_TO_RUN': 'ready_to_run',
                    'RUNNING': 'running'
                }
            }
        `.trim()
        )

        window.chrome.app = {
            ...STATIC_DATA,

            get isInstalled() {
                return false
            },

            getDetails: function getDetails() {
                if (arguments.length) {
                    throw makeError.ErrorInInvocation(`getDetails`)
                }
                return null
            },
            getIsInstalled: function getDetails() {
                if (arguments.length) {
                    throw makeError.ErrorInInvocation(`getIsInstalled`)
                }
                return false
            },
            runningState: function getDetails() {
                if (arguments.length) {
                    throw makeError.ErrorInInvocation(`runningState`)
                }
                return 'cannot_run'
            }
        }
        utils.patchToStringNested(window.chrome.app)
    } catch (e) {
        console.error('Fake chrome app: ' + e)
    }
}</value>
  </data>
  <data name="SeleniumStealth_FakeChromeRuntime" xml:space="preserve">
    <value>(runOnInsecureOrigins) =&gt; {
    console.log('Fake chrome runtime injected!')
    try {
        Object.defineProperty(navigator, 'maxTouchPoints', { get: () =&gt; 1 })
        Object.defineProperty(navigator.connection, 'rtt', { get: () =&gt; 100 })

        const STATIC_DATA = {
            'OnInstalledReason': {
                'CHROME_UPDATE': 'chrome_update',
                'INSTALL': 'install',
                'SHARED_MODULE_UPDATE': 'shared_module_update',
                'UPDATE': 'update'
            },
            'OnRestartRequiredReason': {
                'APP_UPDATE': 'app_update',
                'OS_UPDATE': 'os_update',
                'PERIODIC': 'periodic'
            },
            'PlatformArch': {
                'ARM': 'arm',
                'ARM64': 'arm64',
                'MIPS': 'mips',
                'MIPS64': 'mips64',
                'X86_32': 'x86-32',
                'X86_64': 'x86-64'
            },
            'PlatformNaclArch': {
                'ARM': 'arm',
                'MIPS': 'mips',
                'MIPS64': 'mips64',
                'X86_32': 'x86-32',
                'X86_64': 'x86-64'
            },
            'PlatformOs': {
                'ANDROID': 'android',
                'CROS': 'cros',
                'LINUX': 'linux',
                'MAC': 'mac',
                'OPENBSD': 'openbsd',
                'WIN': 'win'
            },
            'RequestUpdateCheckStatus': {
                'NO_UPDATE': 'no_update',
                'THROTTLED': 'throttled',
                'UPDATE_AVAILABLE': 'update_available'
            }
        }
        if (!window.chrome) {
            Object.defineProperty(window, 'chrome', {
                writable: true,
                enumerable: true,
                configurable: false,
                value: {}
            })
        }

        const existsAlready = 'runtime' in window.chrome
        const isNotSecure = !window.location.protocol.startsWith('https')
        if (existsAlready || (isNotSecure &amp;&amp; !runOnInsecureOrigins)) {
            return
        }

        window.chrome.runtime = {
            ...STATIC_DATA,
            get id() {
                return undefined
            },
            connect: null,
            sendMessage: null
        }

        const makeCustomRuntimeErrors = (preamble, method, extensionId) =&gt; ({
            NoMatchingSignature: new TypeError(
                preamble + `No matching signature.`
            ),
            MustSpecifyExtensionID: new TypeError(
                preamble +
                `${method} called from a webpage must specify an Extension ID (string) for its first argument.`
            ),
            InvalidExtensionID: new TypeError(
                preamble + `Invalid extension id: '${extensionId}'`
            )
        })

        const isValidExtensionID = str =&gt;
            str.length === 32 &amp;&amp; str.toLowerCase().match(/^[a-p]+$/)

        const sendMessageHandler = {
            apply: function (target, ctx, args) {
                const [extensionId, options, responseCallback] = args || []
                const errorPreamble = `Error in invocation of runtime.sendMessage(optional string extensionId, any message, optional object options, optional function responseCallback): `
                const Errors = makeCustomRuntimeErrors(
                    errorPreamble,
                    `chrome.runtime.sendMessage()`,
                    extensionId
                )

                const noArguments = args.length === 0
                const tooManyArguments = args.length &gt; 4
                const incorrectOptions = options &amp;&amp; typeof options !== 'object'
                const incorrectResponseCallback =
                    responseCallback &amp;&amp; typeof responseCallback !== 'function'
                if (
                    noArguments ||
                    tooManyArguments ||
                    incorrectOptions ||
                    incorrectResponseCallback
                ) {
                    throw Errors.NoMatchingSignature
                }

                if (args.length &lt; 2) {
                    throw Errors.MustSpecifyExtensionID
                }

                if (typeof extensionId !== 'string') {
                    throw Errors.NoMatchingSignature
                }

                if (!isValidExtensionID(extensionId)) {
                    throw Errors.InvalidExtensionID
                }

                return undefined
            }
        }
        utils.mockWithProxy(
            window.chrome.runtime,
            'sendMessage',
            function sendMessage() { },
            sendMessageHandler
        )

        const connectHandler = {
            apply: function (target, ctx, args) {
                const [extensionId, connectInfo] = args || []

                const errorPreamble = `Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): `
                const Errors = makeCustomRuntimeErrors(
                    errorPreamble,
                    `chrome.runtime.connect()`,
                    extensionId
                )

                const noArguments = args.length === 0
                const emptyStringArgument = args.length === 1 &amp;&amp; extensionId === ''
                if (noArguments || emptyStringArgument) {
                    throw Errors.MustSpecifyExtensionID
                }

                const tooManyArguments = args.length &gt; 2
                const incorrectConnectInfoType =
                    connectInfo &amp;&amp; typeof connectInfo !== 'object'

                if (tooManyArguments || incorrectConnectInfoType) {
                    throw Errors.NoMatchingSignature
                }

                const extensionIdIsString = typeof extensionId === 'string'
                if (extensionIdIsString &amp;&amp; extensionId === '') {
                    throw Errors.MustSpecifyExtensionID
                }
                if (extensionIdIsString &amp;&amp; !isValidExtensionID(extensionId)) {
                    throw Errors.InvalidExtensionID
                }

                const validateConnectInfo = ci =&gt; {
                    if (args.length &gt; 1) {
                        throw Errors.NoMatchingSignature
                    }
                    if (Object.keys(ci).length === 0) {
                        throw Errors.MustSpecifyExtensionID
                    }
                    Object.entries(ci).forEach(([k, v]) =&gt; {
                        const isExpected = ['name', 'includeTlsChannelId'].includes(k)
                        if (!isExpected) {
                            throw new TypeError(
                                errorPreamble + `Unexpected property: '${k}'.`
                            )
                        }
                        const MismatchError = (propName, expected, found) =&gt;
                            TypeError(
                                errorPreamble +
                                `Error at property '${propName}': Invalid type: expected ${expected}, found ${found}.`
                            )
                        if (k === 'name' &amp;&amp; typeof v !== 'string') {
                            throw MismatchError(k, 'string', typeof v)
                        }
                        if (k === 'includeTlsChannelId' &amp;&amp; typeof v !== 'boolean') {
                            throw MismatchError(k, 'boolean', typeof v)
                        }
                    })
                }
                if (typeof extensionId === 'object') {
                    validateConnectInfo(extensionId)
                    throw Errors.MustSpecifyExtensionID
                }

                return utils.patchToStringNested(makeConnectResponse())
            }
        }
        utils.mockWithProxy(
            window.chrome.runtime,
            'connect',
            function connect() { },
            connectHandler
        )

        function makeConnectResponse() {
            const onSomething = () =&gt; ({
                addListener: function addListener() { },
                dispatch: function dispatch() { },
                hasListener: function hasListener() { },
                hasListeners: function hasListeners() {
                    return false
                },
                removeListener: function removeListener() { }
            })

            const response = {
                name: '',
                sender: undefined,
                disconnect: function disconnect() { },
                onDisconnect: onSomething(),
                onMessage: onSomething(),
                postMessage: function postMessage() {
                    if (!arguments.length) {
                        throw new TypeError(`Insufficient number of arguments.`)
                    }
                    throw new Error(`Attempting to use a disconnected port object`)
                }
            }
            return response
        }
    } catch (e) {
        console.error('Fake chrome runtime: ' + e)
    }
}</value>
  </data>
  <data name="SeleniumStealth_FakePluginsAndMimes" xml:space="preserve">
    <value>() =&gt; {
    console.log('Fake plugins and mimes injected!')
    try {
        const fns = {};
        fns.generatePluginArray = (utils, fns) =&gt; pluginsData =&gt; {
            return fns.generateMagicArray(utils, fns)(
                pluginsData,
                PluginArray.prototype,
                Plugin.prototype,
                'name'
            )
        }
        fns.generateFunctionMocks = utils =&gt; (
            proto,
            itemMainProp,
            dataArray
        ) =&gt; ({

            item: utils.createProxy(proto.item, {
                apply(target, ctx, args) {
                    if (!args.length) {
                        throw new TypeError(
                            `Failed to execute 'item' on '${proto[Symbol.toStringTag]
                            }': 1 argument required, but only 0 present.`
                        )
                    }

                    const isInteger = args[0] &amp;&amp; Number.isInteger(Number(args[0]))

                    return (isInteger ? dataArray[Number(args[0])] : dataArray[0]) || null
                }
            }),

            namedItem: utils.createProxy(proto.namedItem, {
                apply(target, ctx, args) {
                    if (!args.length) {
                        throw new TypeError(
                            `Failed to execute 'namedItem' on '${proto[Symbol.toStringTag]
                            }': 1 argument required, but only 0 present.`
                        )
                    }
                    return dataArray.find(mt =&gt; mt[itemMainProp] === args[0]) || null
                }
            }),

            refresh: proto.refresh
                ? utils.createProxy(proto.refresh, {
                    apply(target, ctx, args) {
                        return undefined
                    }
                })
                : undefined
        })
        fns.generateMagicArray = (utils, fns) =&gt;
            function (
                dataArray = [],
                proto = MimeTypeArray.prototype,
                itemProto = MimeType.prototype,
                itemMainProp = 'type'
            ) {

                const defineProp = (obj, prop, value) =&gt;
                    Object.defineProperty(obj, prop, {
                        value,
                        writable: false,
                        enumerable: false,
                        configurable: false
                    })

                const makeItem = data =&gt; {
                    const item = {}
                    for (const prop of Object.keys(data)) {
                        if (prop.startsWith('__')) {
                            continue
                        }
                        defineProp(item, prop, data[prop])
                    }

                    return Object.create(itemProto, Object.getOwnPropertyDescriptors(item))
                }

                const magicArray = []

                dataArray.forEach(data =&gt; {
                    magicArray.push(makeItem(data))
                })

                magicArray.forEach(entry =&gt; {
                    defineProp(magicArray, entry[itemMainProp], entry)
                })

                const magicArrayObj = Object.create(proto, {
                    ...Object.getOwnPropertyDescriptors(magicArray),

                    length: {
                        value: magicArray.length,
                        writable: false,
                        enumerable: false,
                        configurable: true
                    }
                })

                const functionMocks = fns.generateFunctionMocks(utils)(
                    proto,
                    itemMainProp,
                    magicArray
                )

                const magicArrayObjProxy = new Proxy(magicArrayObj, {
                    get(target, key = '') {

                        if (key === 'item') {
                            return functionMocks.item
                        }
                        if (key === 'namedItem') {
                            return functionMocks.namedItem
                        }
                        if (proto === PluginArray.prototype &amp;&amp; key === 'refresh') {
                            return functionMocks.refresh
                        }

                        return utils.cache.Reflect.get(...arguments)
                    },
                    ownKeys(target) {

                        const keys = []
                        const typeProps = magicArray.map(mt =&gt; mt[itemMainProp])
                        typeProps.forEach((_, i) =&gt; keys.push(`${i}`))
                        typeProps.forEach(propName =&gt; keys.push(propName))
                        return keys
                    }
                })

                return magicArrayObjProxy
            }
        fns.generateMimeTypeArray = (utils, fns) =&gt; mimeTypesData =&gt; {
            return fns.generateMagicArray(utils, fns)(
                mimeTypesData,
                MimeTypeArray.prototype,
                MimeType.prototype,
                'type'
            )
        }

        const data = {
            'mimeTypes': [
                {
                    'type': 'application/pdf',
                    'suffixes': 'pdf',
                    'description': '',
                    '__pluginName': 'Chrome PDF Viewer'
                },
                {
                    'type': 'application/x-google-chrome-pdf',
                    'suffixes': 'pdf',
                    'description': 'Portable Document Format',
                    '__pluginName': 'Chrome PDF Plugin'
                },
                {
                    'type': 'application/x-nacl',
                    'suffixes': '',
                    'description': 'Native Client Executable',
                    '__pluginName': 'Native Client'
                },
                {
                    'type': 'application/x-pnacl',
                    'suffixes': '',
                    'description': 'Portable Native Client Executable',
                    '__pluginName': 'Native Client'
                }
            ],
            'plugins': [
                {
                    'name': 'Chrome PDF Plugin',
                    'filename': 'internal-pdf-viewer',
                    'description': 'Portable Document Format',
                    '__mimeTypes': ['application/x-google-chrome-pdf']
                },
                {
                    'name': 'Chrome PDF Viewer',
                    'filename': 'mhjfbmdgcfjbbpaeojofohoefgiehjai',
                    'description': '',
                    '__mimeTypes': ['application/pdf']
                },
                {
                    'name': 'Native Client',
                    'filename': 'internal-nacl-plugin',
                    'description': '',
                    '__mimeTypes': ['application/x-nacl', 'application/x-pnacl']
                }
            ]
        };

        const hasPlugins = 'plugins' in navigator &amp;&amp; navigator.plugins.length
        if (hasPlugins) {
            return
        }

        const mimeTypes = fns.generateMimeTypeArray(utils, fns)(data.mimeTypes)
        const plugins = fns.generatePluginArray(utils, fns)(data.plugins)

        for (const pluginData of data.plugins) {
            pluginData.__mimeTypes.forEach((type, index) =&gt; {
                plugins[pluginData.name][index] = mimeTypes[type]
                plugins[type] = mimeTypes[type]
                Object.defineProperty(mimeTypes[type], 'enabledPlugins', {
                    value: JSON.parse(JSON.stringify(plugins[pluginData.name])),
                    writable: false,
                    enumerable: false,
                    configurable: false
                })
            })
        }

        const patchNavigator = (name, value) =&gt;
            utils.replaceProperty(Object.getPrototypeOf(navigator), name, {
                get() {
                    return value
                }
            })

        patchNavigator('mimeTypes', mimeTypes)
        patchNavigator('plugins', plugins)

    } catch (e) {
        console.error('Fake plugins and mimes: ' + e)
    }
}</value>
  </data>
  <data name="SeleniumStealth_FakeWindowOuterDimensions" xml:space="preserve">
    <value>() =&gt; {
    console.log('Fake window outer dimensions injected!')
    try {
        if (window.outerWidth &amp;&amp; window.outerHeight) {
            return
        }
        const windowFrame = 85
        window.outerWidth = window.innerWidth
        window.outerHeight = window.innerHeight + windowFrame
    } catch (e) {
        console.error('Fake window outer dimensions: ' + e)
    }
}</value>
  </data>
  <data name="SeleniumStealth_HideWebDriver" xml:space="preserve">
    <value>() =&gt; {
    console.log('Hide webdriver injected!')

    try {
        Object.defineProperty(window, 'navigator', {
            value: new Proxy(navigator, {
                has: (target, key) =&gt; (key === 'webdriver' ? false : key in target),
                get: (target, key) =&gt;
                    key === 'webdriver'
                        ? false
                        : typeof target[key] === 'function'
                            ? target[key].bind(target)
                            : target[key],
            }),
        });
    } catch (e) {
        console.error('Hide webdriver injected: ' + e);
    }
}</value>
  </data>
  <data name="SeleniumStealth_iFrameProxy" xml:space="preserve">
    <value>() =&gt; {
    console.log('iFrame proxy injected!')
    try {
        const addContentWindowProxy = iframe =&gt; {
            const contentWindowProxy = {
                get(target, key) {

                    if (key === 'self') {
                        return this
                    }

                    if (key === 'frameElement') {
                        return iframe
                    }
                    return Reflect.get(target, key)
                }
            }

            if (!iframe.contentWindow) {
                const proxy = new Proxy(window, contentWindowProxy)
                Object.defineProperty(iframe, 'contentWindow', {
                    get() {
                        return proxy
                    },
                    set(newValue) {
                        return newValue
                    },
                    enumerable: true,
                    configurable: false
                })
            }
        }

        const handleIframeCreation = (target, thisArg, args) =&gt; {
            const iframe = target.apply(thisArg, args)

            const _iframe = iframe
            const _srcdoc = _iframe.srcdoc

            Object.defineProperty(iframe, 'srcdoc', {
                configurable: true,
                get: function () {
                    return _iframe.srcdoc
                },
                set: function (newValue) {
                    addContentWindowProxy(this)

                    Object.defineProperty(iframe, 'srcdoc', {
                        configurable: false,
                        writable: false,
                        value: _srcdoc
                    })
                    _iframe.srcdoc = newValue
                }
            })
            return iframe
        }

        const addIframeCreationSniffer = () =&gt; {

            const createElement = {

                get(target, key) {
                    return Reflect.get(target, key)
                },
                apply: function (target, thisArg, args) {
                    const isIframe =
                        args &amp;&amp; args.length &amp;&amp; `${args[0]}`.toLowerCase() === 'iframe'
                    if (!isIframe) {

                        return target.apply(thisArg, args)
                    } else {
                        return handleIframeCreation(target, thisArg, args)
                    }
                }
            }

            document.createElement = new Proxy(
                document.createElement,
                createElement
            )
        }

        addIframeCreationSniffer()
    } catch (e) {
        console.error('iFrame proxy: ' + e)
    }
}</value>
  </data>
  <data name="SeleniumStealth_QueryProxy" xml:space="preserve">
    <value>() =&gt; {
    console.log('Query proxy injected!')
    try {
        const handler = {
            apply: function (target, ctx, args) {
                const param = (args || [])[0]

                if (param &amp;&amp; param.name &amp;&amp; param.name === 'notifications') {
                    const result = { state: Notification.permission }
                    Object.setPrototypeOf(result, PermissionStatus.prototype)
                    return Promise.resolve(result)
                }

                return utils.cache.Reflect.apply(...arguments)
            }
        }

        utils.replaceWithProxy(
            window.navigator.permissions.__proto__,
            'query',
            handler
        )
    } catch (e) {
        console.error('Query proxy: ' + e)
    }
}</value>
  </data>
  <data name="SeleniumStealth_RequiredUtilityPack" xml:space="preserve">
    <value>() =&gt; {
    console.log('Required utility pack injected!')
    utils = {}

    utils.stripProxyFromErrors = (handler = {}) =&gt; {
        const newHandler = {}

        const traps = Object.getOwnPropertyNames(handler)
        traps.forEach(trap =&gt; {
            newHandler[trap] = function () {
                try {

                    return handler[trap].apply(this, arguments || [])
                } catch (err) {

                    if (!err || !err.stack || !err.stack.includes(`at `)) {
                        throw err
                    }

                    const stripWithBlacklist = stack =&gt; {
                        const blacklist = [
                            `at Reflect.${trap} `,
                            `at Object.${trap} `,
                            `at Object.newHandler.&lt;computed&gt; [as ${trap}] `
                        ]
                        return (
                            err.stack
                                .split('\n')

                                .filter((line, index) =&gt; index !== 1)

                                .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))
                                .join('\n')
                        )
                    }

                    const stripWithAnchor = stack =&gt; {
                        const stackArr = stack.split('\n')
                        const anchor = `at Object.newHandler.&lt;computed&gt; [as ${trap}] `
                        const anchorIndex = stackArr.findIndex(line =&gt;
                            line.trim().startsWith(anchor)
                        )
                        if (anchorIndex === -1) {
                            return false
                        }

                        stackArr.splice(1, anchorIndex)
                        return stackArr.join('\n')
                    }

                    err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)

                    throw err
                }
            }
        })
        return newHandler
    }

    utils.stripErrorWithAnchor = (err, anchor) =&gt; {
        const stackArr = err.stack.split('\n')
        const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))
        if (anchorIndex === -1) {
            return err
        }

        stackArr.splice(1, anchorIndex)
        err.stack = stackArr.join('\n')
        return err
    }

    utils.replaceProperty = (obj, propName, descriptorOverrides = {}) =&gt; {
        return Object.defineProperty(obj, propName, {

            ...(Object.getOwnPropertyDescriptor(obj, propName) || {}),

            ...descriptorOverrides
        })
    }

    utils.preloadCache = () =&gt; {
        if (utils.cache) {
            return
        }
        utils.cache = {

            Reflect: {
                get: Reflect.get.bind(Reflect),
                apply: Reflect.apply.bind(Reflect)
            },

            nativeToStringStr: Function.toString + ''
        }
    }

    utils.makeNativeString = (name = '') =&gt; {

        utils.preloadCache()
        return utils.cache.nativeToStringStr.replace('toString', name || '')
    }

    utils.patchToString = (obj, str = '') =&gt; {
        utils.preloadCache()

        const toStringProxy = new Proxy(Function.prototype.toString, {
            apply: function (target, ctx) {

                if (ctx === Function.prototype.toString) {
                    return utils.makeNativeString('toString')
                }

                if (ctx === obj) {

                    return str || utils.makeNativeString(obj.name)
                }

                const hasSameProto = Object.getPrototypeOf(
                    Function.prototype.toString
                ).isPrototypeOf(ctx.toString)
                if (!hasSameProto) {

                    return ctx.toString()
                }
                return target.call(ctx)
            }
        })
        utils.replaceProperty(Function.prototype, 'toString', {
            value: toStringProxy
        })
    }

    utils.patchToStringNested = (obj = {}) =&gt; {
        return utils.execRecursively(obj, ['function'], utils.patchToString)
    }

    utils.redirectToString = (proxyObj, originalObj) =&gt; {
        utils.preloadCache()

        const toStringProxy = new Proxy(Function.prototype.toString, {
            apply: function (target, ctx) {

                if (ctx === Function.prototype.toString) {
                    return utils.makeNativeString('toString')
                }

                if (ctx === proxyObj) {
                    const fallback = () =&gt;
                        originalObj &amp;&amp; originalObj.name
                            ? utils.makeNativeString(originalObj.name)
                            : utils.makeNativeString(proxyObj.name)

                    return originalObj + '' || fallback()
                }

                const hasSameProto = Object.getPrototypeOf(
                    Function.prototype.toString
                ).isPrototypeOf(ctx.toString)
                if (!hasSameProto) {

                    return ctx.toString()
                }

                return target.call(ctx)
            }
        })
        utils.replaceProperty(Function.prototype, 'toString', {
            value: toStringProxy
        })
    }

    utils.replaceWithProxy = (obj, propName, handler) =&gt; {
        utils.preloadCache()
        const originalObj = obj[propName]
        const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))

        utils.replaceProperty(obj, propName, { value: proxyObj })
        utils.redirectToString(proxyObj, originalObj)

        return true
    }

    utils.mockWithProxy = (obj, propName, pseudoTarget, handler) =&gt; {
        utils.preloadCache()
        const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))

        utils.replaceProperty(obj, propName, { value: proxyObj })
        utils.patchToString(proxyObj)

        return true
    }

    utils.createProxy = (pseudoTarget, handler) =&gt; {
        utils.preloadCache()
        const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))
        utils.patchToString(proxyObj)

        return proxyObj
    }

    utils.splitObjPath = objPath =&gt; ({

        objName: objPath
            .split('.')
            .slice(0, -1)
            .join('.'),

        propName: objPath.split('.').slice(-1)[0]
    })

    utils.replaceObjPathWithProxy = (objPath, handler) =&gt; {
        const { objName, propName } = utils.splitObjPath(objPath)
        const obj = eval(objName)
        return utils.replaceWithProxy(obj, propName, handler)
    }

    utils.execRecursively = (obj = {}, typeFilter = [], fn) =&gt; {
        function recurse(obj) {
            for (const key in obj) {
                if (obj[key] === undefined) {
                    continue
                }
                if (obj[key] &amp;&amp; typeof obj[key] === 'object') {
                    recurse(obj[key])
                } else {
                    if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) {
                        fn.call(this, obj[key])
                    }
                }
            }
        }
        recurse(obj)
        return obj
    }

    utils.stringifyFns = (fnObj = { hello: () =&gt; 'world' }) =&gt; {

        function fromEntries(iterable) {
            return [...iterable].reduce((obj, [key, val]) =&gt; {
                obj[key] = val
                return obj
            }, {})
        }
        return (Object.fromEntries || fromEntries)(
            Object.entries(fnObj)
                .filter(([key, value]) =&gt; typeof value === 'function')
                .map(([key, value]) =&gt; [key, value.toString()])
        )
    }

    utils.materializeFns = (fnStrObj = { hello: () =&gt; 'world' }) =&gt; {
        return Object.fromEntries(
            Object.entries(fnStrObj).map(([key, value]) =&gt; {
                if (value.startsWith('function')) {

                    return [key, eval(`() =&gt; ${value}`)()]
                } else {

                    return [key, eval(value)]
                }
            })
        )
    }

    utils.preloadCache()
}</value>
  </data>
  <data name="UndetectedChromeDriver" xml:space="preserve">
    <value>() =&gt; {
    console.log('UndetectedChromedriver injected!')

    try {
        Object.defineProperty(window, 'navigator', {
            value: new Proxy(navigator, {
                has: (target, key) =&gt; (key === 'webdriver' ? false : key in target),
                get: (target, key) =&gt;
                    key === 'webdriver'
                        ? false
                        : typeof target[key] === 'function'
                            ? target[key].bind(target)
                            : target[key],
            }),
        });

        Object.defineProperty(navigator, 'maxTouchPoints', { get: () =&gt; 1 });
        Object.defineProperty(navigator.connection, 'rtt', { get: () =&gt; 100 });

        window.chrome = {
            app: {
                isInstalled: false,
                InstallState: {
                    DISABLED: 'disabled',
                    INSTALLED: 'installed',
                    NOT_INSTALLED: 'not_installed'
                },
                RunningState: {
                    CANNOT_RUN: 'cannot_run',
                    READY_TO_RUN: 'ready_to_run',
                    RUNNING: 'running'
                }
            },
            runtime: {
                OnInstalledReason: {
                    CHROME_UPDATE: 'chrome_update',
                    INSTALL: 'install',
                    SHARED_MODULE_UPDATE: 'shared_module_update',
                    UPDATE: 'update'
                },
                OnRestartRequiredReason: {
                    APP_UPDATE: 'app_update',
                    OS_UPDATE: 'os_update',
                    PERIODIC: 'periodic'
                },
                PlatformArch: {
                    ARM: 'arm',
                    ARM64: 'arm64',
                    MIPS: 'mips',
                    MIPS64: 'mips64',
                    X86_32: 'x86-32',
                    X86_64: 'x86-64'
                },
                PlatformNaclArch: {
                    ARM: 'arm',
                    MIPS: 'mips',
                    MIPS64: 'mips64',
                    X86_32: 'x86-32',
                    X86_64: 'x86-64'
                },
                PlatformOs: {
                    ANDROID: 'android',
                    CROS: 'cros',
                    LINUX: 'linux',
                    MAC: 'mac',
                    OPENBSD: 'openbsd',
                    WIN: 'win'
                },
                RequestUpdateCheckStatus: {
                    NO_UPDATE: 'no_update',
                    THROTTLED: 'throttled',
                    UPDATE_AVAILABLE: 'update_available'
                }
            }
        }

        if (!window.Notification) {
            window.Notification = {
                permission: 'denied'
            }
        }

        const originalQuery = window.navigator.permissions.query
        window.navigator.permissions.__proto__.query = parameters =&gt;
            parameters.name === 'notifications'
                ? Promise.resolve({ state: window.Notification.permission })
                : originalQuery(parameters)

        const oldCall = Function.prototype.call
        function call() {
            return oldCall.apply(this, arguments)
        }
        Function.prototype.call = call

        const nativeToStringFunctionString = Error.toString().replace(/Error/g, 'toString')
        const oldToString = Function.prototype.toString

        function functionToString() {
            if (this === window.navigator.permissions.query) {
                return 'function query() { [native code] }'
            }
            if (this === functionToString) {
                return nativeToStringFunctionString
            }
            return oldCall.call(oldToString, this)
        }

        Function.prototype.toString = functionToString
    } catch (e) {
        console.error('UndetectedChromedriver: ' + e)
    }
}</value>
  </data>
</root>